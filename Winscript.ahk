;JPGIncWinscriptFlag Start shortcutNames
/* This program was written by Joshua Graham joshua.graham@jpgautomation.com
 * www.jpgautomation.com
 * Anyone may use any part of this code for any non-malicious purpose
 * with or without referencing me. There is No Warranty 
 */
;Do not edit this file.
JPGIncShortcuts := "remove,edit,add,update,new,unpack,"
JPGIncCodeSegments := "autoExecute,defaultHotkeys,display,controller,shortcutLauncher,recompiler,"
;JPGIncWinscriptFlag End shortcutNames
;JPGIncWinscriptFlag Start autoExecute
/*
 * This file is always included first in the compilation process and is the auto execute secion
 * of the script
 */
#NoEnv  ; Recommended for performance and compatibility with future AutoHotkey releases.
; #Warn  ; Enable warnings to assist with detecting common errors.
SendMode Input  ; Recommended for new scripts due to its superior speed and reliability.
SetWorkingDir %A_ScriptDir%  ; Ensures a consistent starting directory.
#SingleInstance force
if not A_IsAdmin
{	Run *RunAs "%A_ScriptFullPath%" 
	ExitApp
}
IfNotExist, Addons
{   MsgBox, 4, JPGInc ERROR, ERROR the Addons folder does not exist. Would you like to create and populate the folder now?
    IfMsgBox, Yes
    {   unpack()
    }
}
GlobalController := new Controller(JPGIncShortcuts, JPGIncCodeSegments)
return
escapeRegex(theString) 
{	return "\Q" theString "\E"
}
inArray(array, item)
{	for key, val in array
    {	if(val == item)
        {	return true
        }
    }
    return false
}
firstIsLast(ByRef theArray, reverse := false)
{	if(reverse)
    {	removed := theArray.remove(theArray.maxIndex())
        theArray.insert(theArray.minIndex() - 1, removed)
    } else
    {	removed := theArray.remove(theArray.minIndex())
        theArray.insert(theArray.maxIndex() + 1, removed)
    }
    return
}
arrayToString(theArray)
{	theString := ""
    for key, aString in theArray
    {	if(trim(aString) == "")
        {	continue
        }
        theString .= aString "`n"
    }
    return theString
}	
removeFromArray(theArray, item)
{   for key, val in theArray
    {  if(val == item)
       {    return theArray.remove(key)
       }
    }
    return
}
;JPGIncWinscriptFlag End autoExecute
;JPGIncWinscriptFlag Start recompiler
class recompiler
{
    beforeFlag := ";JPGIncWinscriptFlag Start "
    afterFlag := ";JPGIncWinscriptFlag End "
    
    __New(args*)
    {   return this
    }
    
    getBeforeFlag()
    {   return this.beforeFlag
    }   
    getAfterFlag()
    {   return this.afterFlag
    }
    
    getRunningCode() 
    {   if(A_IsCompiled) 
        {   MsgBox, , ERROR, ERROR Cannot edit this script because it is already compiled!
            return ""
        ;not yet implemented
        } else 
        {   FileRead, fullScript, % A_ScriptFullPath
        }
        return fullScript
    }
    
    /*
     * Simply appends the given file to the main script without adding a sortcut
     * @param filename
     *  the full path of the file to include OR the name of the file in the %A_scriptdir%\Addons folder
     * @param shortcutName
     *  the name of the shortcut. If blank a shortcut is not added and the file is simply appended to the running code
     */
    doAdd(name, newCode, addShortcut) 
    {   runningCode := this.getSource()
        if(this.joinCode(name, newCode, runningCode, addShortcut)) 
        {   MsgBox, 4, JPGInc Warning, Warning adding this file will overwite existing code`nDo you want to continue?
            IfMsgBox, no 
            {   return
            }
        }
		return this.recompile(runningCode)
    }
    
    /*
     * Edit's existingCode to include newCode in between beforeflag and afterflag optionally updating the defaultShortcutList := "..." to include name ","
     * returns false if the code was added without removing existing code
     * returns true existing code was updated
     */
    joinCode(name, newCode, ByRef existingCode, addShortcut, isUpdate := false) 
    {	if(theStart := RegExMatch(existingCode, "`am)^" this.escapeRegex(this.beforeFlag name) "$")) 
        {   ;we need to replace the existing code
            MsgBox % "here " theStart
            theEnd := RegExMatch(existingCode, "P`am)^" this.escapeRegex(this.afterFlag name) "$", length)
            existingCode := SubStr(existingCode, 1, theStart - 1) SubStr(existingCode, theEnd + length)
        }
        if(! isUpdate)
        {   if(addShortcut && ! theStart) 
            {   ;need to add the shortcut
                existingCode := RegExReplace(existingCode, "`am)^JPGIncShortcuts := ""(.*)""", "JPGIncShortcuts := ""$1" this.escapeDollars(name) ",""", notNeeded, 1)
            } else if (! theStart)
            {   existingCode := RegExReplace(existingCode, "`am)^JPGIncCodeSegments := ""(.*)""", "JPGIncCodeSegments := ""$1" this.escapeDollars(name) ",""", notNeeded, 1)
            }
        }
        if(name == "autoExecute")
        {   theEnd := RegExMatch(existingCode, "P`am)^" this.escapeRegex(this.afterFlag "shortcutNames") "$", length)
            shortcutNames := SubStr(existingCode, 1, theEnd + length)
            otherCode := SubStr(existingCode, theEnd + length)
            ;special case where the code has to be added to the start of the script but after the shortcutNames section
            existingCode := shortcutNames "`n" this.beforeFlag name "`n" newCode "`n" this.afterFlag name "`n" otherCode
        } else
        {   ;append the new code with flags
            existingCode .= "`n" this.beforeFlag name "`n" newCode "`n" this.afterFlag name "`n"
        }
        return theStart != 0
    }
    
    /*
     * removes from the start flag of 'name' to the endflag (inclusive) from 'existingCode'
     * returns 0 if successful
     * returns 1 if unsuccessful
     */
    splitCode(name, ByRef existingCode, deleteShortcut := false)
    {   if(theStart := RegExMatch(existingCode, "`am)^" this.escapeRegex(this.beforeFlag name) "$")) 
        {	theEnd := RegExMatch(existingCode, "P`am)^" this.escapeRegex(this.afterFlag name) "$", length)
            existingCode := SubStr(existingCode, 1, theStart - 1) SubStr(existingCode, theEnd + length)
            existingCode := RegExReplace(existingCode, "\R\R", "`r`n")
            if(deleteShortcut)
            {   existingCode := RegExReplace(existingCode, "m)""(.*)" this.escapeRegex(name) ",", """$1", notNeeded, 1)
            }
            return 0
        }
        return 1
    }
    /*
     * Appends the given file to the main script also adding it to the shortcut list
     */
    addShortcut(name, newCode) 
    {   return this.doAdd(name, newCode, true)
    }
    
    add(name, newCode) 
    {   return this.doAdd(name, newCode, false)
    }
    
    /*
     * Removes the code snipit from the main file
     */
    remove(name, update := false) 
    {   existingCode := this.getSource()
        if(this.splitCode(name, existingCode, deleteShortcut := true))
        {   MsgBox, , JPGInc Error, Error code segment not found in the currently running code!
            return 
        }
        return this.recompile(existingCode)
    }
    
    /* 
     * Updates an existing code snipit within the file
	 * Not yet implemented
     */
    update(name, newCode) 
    {	existingCode := this.getSource()
        if(this.splitCode(name, existingCode))
        {   MsgBox, 4, JPGInc Warning, Warning existing code was not found (or removed) do you wish to continue?
			IfMsgBox No
			{	return
			}
		}
		this.joinCode(name, newCode, existingCode, addShortcut := false, isUpdate := true)
		return this.recompile(existingCode)
    }
    
    /*
     * Checks if the given code will compile
     * returns 0 if the code compiles without any problems
     * returns the compilation errors otherwise
     */
    checkCodeSyntax(code) 
    {
        FileDelete, JPGIncTempFile.ahk
        FileDelete, errorlog.txt
        FileAppend, % "exitapp`n" code, JPGIncTempFile.ahk
        RunWait, %A_AhkPath% /ErrorStdOut JPGIncTempFile.ahk > errorlog.txt
        FileDelete, JPGIncTempFile.ahk
        FileRead, errorlog, errorlog.txt
        if(errorlog)
        {   return errorlog
        }
        return false
    }
    
    /*
     * returns the code of the currently running script
     */
    getSource() 
    {
        if(A_IsCompiled) 
        {
            ;not yet implemented
        } else 
        {
            FileRead, fullScript, % A_ScriptFullPath
        }
        return fullScript
    }
    
    recompile(newCode) 
    {	if(A_IsCompiled) 
        {	return
            ;not implemented
        } else 
        {	FileMove, % A_scriptfullpath, % a_scriptfullpath ".backup", 1
            FileAppend, % newCode, % A_scriptfullpath
            Reload
            Sleep 1000 ; If successful, the reload will close this instance during the Sleep, so the line below will never be reached.
			WinClose, ahk_class #32770
			FileMove, % A_ScriptFullPath, % A_ScriptFullPath ".failed", 1
			FileMove, % A_scriptfullpath ".backup", % a_scriptfullpath, 1
            MsgBox, 4, JPGInc ERROR, ERROR The script could not be reloaded. Would you like to open it for editing?
            IfMsgBox, Yes 
            {   Run, edit "%A_scriptfullpath%.failed", , UseErrorLevel
				if(errorlevel)
				{	run, % "notepad """ A_scriptfullpath ".failed"""
				}
            }
            return
        }
    }
	
	doMatch(haystack, needle)
	{	return RegExMatch(haystack, "`am)^" needle "$")
	}
	
	escapeRegex(theString) 
	{	return "\Q" RegExReplace(theString, "(\Q|\E)", "\$1") "\E"
	}
	
	escapeDollars(theString)
	{	StringReplace, theString, theString, $, $$, all
		return theString
	}
}
;JPGIncWinscriptFlag End recompiler
;JPGIncWinscriptFlag Start shortcutLauncher
/* This is the class that will be loaded when entering script mode 
 * Displays a list of shorcuts to choose from
 */
shortcutLauncher(controller)
{	className := controller.getChoice(controller.getShortcuts(), "Select script to run")
	if(className == "cancelled")
	{	return
	}
	StringReplace, className, className, %A_space%, _ , All
	controller.setContext(className)
	if(IsObject(%className%))
	{	new %className%(controller)
	} else if((argCount := IsFunc(className)))
	{	if(argCount == 1)
		{	%className%()
		} else
		{	%className%(controller)
		}
	} else if(IsLabel(className))
	{	gosub, %className%
	}
	return
}
;JPGIncWinscriptFlag End shortcutLauncher
;JPGIncWinscriptFlag Start controller
class Controller
{	display := new OnScreen(this)
	context := ""
	shortcuts := ""
	codeSegments := ""
	allShortcuts := ""
	
	__new(shortcuts, codeSegments)
	{	this.shortcuts := StrSplit(shortcuts, ",")
		this.shortcuts.remove(this.shortcuts.maxIndex())
		this.codeSegments := StrSplit(codeSegments, ",")		
		this.codeSegments.remove(this.codeSegments.maxIndex())
		this.allShortcuts := StrSplit(shortcuts "," codeSegments, ",")
		this.allShortcuts.remove(this.allShortcuts.maxIndex())
		return this
	}
	
	enterScriptMode()
	{	this.context := "shortcutLauncher"
		shortcutLauncher(this)
		return
	}
	mouseClick()
	{	this.display.mouseClick()
		return
	}
	esc()
	{	this.display.esc()
		return
	}
	showMessage(message, params*)
	{	return this.display.showMessage(message, params)
	}
	clearDisplay()
	{	return this.display.hide()
	}
	getChoice(choices, message := "", params*)
	{	return this.display.getChoice(choices, message, params)
	}
	getInput(message, params*)
	{	return this.display.getInput(message, params)
	}
	setContext(newContext)
	{	this.context := newContext
		return
	}
	getContext()
	{	return this.context
	}
	getShortcuts()
	{	return this.shortcuts
	}
	getCodeSegments()
	{	return this.codeSegments
	}
	getAllShortcuts()
	{	return this.allShortcuts
	}
	isValidShortcut(newShortcut)
	{	if(newShortcut == "")
		{	return false
		}
		IfInString, newShortcut, `,
		{	return false
		}
		return ! (this.shortcutExists(newShortcut) || this.codeSegmentExists(newShortcut))
	}
	shortcutExists(newShortcut)
	{	newShortcut := trim(newShortcut)
		if(newShortcut == "")
		{	return false
		}
		IfInString, newShortcut, `,
		{	return false
		}
		return this.inArray(this.shortcuts, newShortcut)
	}
	codeSegmentExists(newShortcut)
	{	newShortcut := trim(newShortcut)
		if(newShortcut == "")
		{	return false
		}
		IfInString, newShortcut, `,
		{	return false
		}
		return this.inArray(this.codeSegments, newShortcut)
	}
	codeOrShortcutExists(shortcut)
	{	return this.inArray(this.shortcuts, shortcut) || this.inArray(this.codeSegments, shortcut)
	}
	inArray(array, item)
	{	for key, val in array
		{	if(val == item)
			{	return true
			}
		}
		return false
	}
	edit(filename)
	{	Run, edit "%filename%", , UseErrorLevel
		if(errorlevel)
		{	run, notepad "%filename%"
		}
		return
	}
	toggleHighVisiblity()
	{	this.display.toggleVisiblitySettings()
		return
	}
}
;JPGIncWinscriptFlag End controller
;JPGIncWinscriptFlag Start defaultHotkeys
#If
;Capslock + Esc exits the program
~CapsLock & Esc::
~Esc & CapsLock::
{	KeyWait capslock
	KeyWait esc
	SetCapsLockState, off
	ExitApp
}
;the default keys to enter 'script' mode are shift and capslock together
~shift & CapsLock::
~CapsLock & Shift::
{	KeyWait shift
	KeyWait capslock
	SetCapsLockState, off
	GlobalController.enterScriptMode()
	return
}
;clicking a mouse button by default will leave script mode
~LButton::
~RButton::
~MButton::
{	GlobalController.mouseClick()
	return
}
;
~Esc::
{	GlobalController.esc()
	return
}
;set the display to be black or outlined
#if globalController.getContext() != ""
~capslock & v::
~v & capslock::
{	SetCapsLockState, off
	globalController.toggleHighVisiblity()
	KeyWait, v
	return
}
;JPGIncWinscriptFlag End defaultHotkeys
;JPGIncWinscriptFlag Start remove
/* this function allows the user to remove a code segment from the running code
 * The user is presented with a list of code segments and, if they select one
 * it is removed from the running code and the script is reloaded.
 * @param controller
 *		An instance of the Controller class
 */
remove(controller)
{	while(true)
	{	toRemove := controller.getChoice(controller.getAllShortcuts(), "Select a code segment/shortcut to remove")
		if(toRemove == "cancelled")
		{	return
		}
		if(toRemove == "autoExecute")
		{	MsgBox, , ERROR, Error you cannot remove the autoExecute section. Use edit/update instead
			return
		}
		if(controller.codeOrShortcutExists(toRemove))
		{	MsgBox, 4, Warning, Are you sure you wish to remove the code segment %toRemove%?
			IfMsgBox, No
			{	continue
			}
			r := new recompiler()
			r.remove(toRemove)
		} else
		{	MsgBox, , Error, Error that shortcut does not exist
		}
	}
	return 
}
;JPGIncWinscriptFlag End remove
;JPGIncWinscriptFlag Start update
/* This function updates a code segment within the running code
 * 
 * The user is presented with a list of code segments and if one
 * is selected it is removed and replaced with the new code
 *
 * If a file exists in the addons folder with the same name of
 * the code segment that the user selects then the contents of 
 * that file is used to replace the removed code otherwise the
 * user is prompted to select the new file
 *
 * @param controller
 * 		An instance of the Controller class
 */
update(controller)
{	while(true)
	{	;get the name of the code segment to update
		toUpdate := controller.getChoice(controller.getAllShortcuts(), "Select a code segment to update")
		if(toUpdate == "cancelled")
		{	return
		}
		if(controller.codeOrShortcutExists(toUpdate))
		{	;check if a file with the same name exists in the addons folder
			IfExist, % A_scriptdir "\Addons\" toUpdate ".ahk"
			{	FileRead, newCode, % A_ScriptDir "\Addons\" toUpdate ".ahk"
			} else
			{	controller.showMessage("Select the file to load", ignoreMouseClicks := true)
				FileSelectFile, dir, 12 ,% A_ScriptDir "\Addons"
				if(errorlevel)
				{	controller.clearDisplay()
					return ;the user cancelled
				}
				controller.clearDisplay()
				FileRead, newCode, % dir
			}
			if(! newCode)
			{	MsgBox, , Error, Error file could not be read or was empty
				return
			}
			MsgBox, 4, Warning, Are you sure you wish to update the shortcut %toUpdate%?
			IfMsgBox, No
			{	continue
			}
			r := new recompiler()
			r.update(toUpdate, newCode)
		} else
		{	MsgBox, , Error, Error that shortcut does not exist
		}
	}
	return 
}
;JPGIncWinscriptFlag End update
;JPGIncWinscriptFlag Start edit
/* This function opens a code segments file for editing 
 * as long as the file is present in the Addons folder
 * @param controller
 *		An instance of the Controller class
 */
edit(controller)
{	while(true)
	{	;get the name of the code segment to edit
		toEdit := controller.getChoice(controller.getAllShortcuts(), "Select a code segment/shortcut to edit")
		if(toEdit == "cancelled")
		{	return
		}
		if(controller.codeOrShortcutExists(toEdit)) ;this isn't really neccesarry...
		{	IfNotExist, % A_ScriptDir "\Addons\" toEdit ".ahk"
			{	MsgBox, , JPGInc ERROR, ERROR file does not exists in the Addons folder.
				return
			}
			run, edit "%A_ScriptDir%\Addons\%toEdit%.ahk", , UseErrorLevel
			if(errorLevel)
			{	run, % "notepad """ A_ScriptDir "\Addons\" toEdit ".ahk"""
			}
			return
		} else
		{	MsgBox, , JPGInc ERROR, ERROR that shortcut does not exist!
		}
	}
}
;JPGIncWinscriptFlag End edit
;JPGIncWinscriptFlag Start new
class new
{	
	
	__new(controller)
	{	shortcutName := scriptName := controller.getInput("Enter the name of your new script. Ideally the name will be the same as the shortcut you intend to use")
		if(scriptName == "cancelled" || trim(scriptName) == "")
		{	return
		}
		StringReplace, shortcutName, shortcutName, %A_space%, _, All
		IfNotInString, scriptName, .
		{	scriptname .= ".ahk"
		}
		{	IfExist, addons\%scriptName%
			{	MsgBox, 4, JPGInc Warning, Warning, the file %scriptName% already exists in the Addons folder. Would you like to open it for editing?
				IfMsgBox, Yes
				{	controller.edit("addons\" scriptName)
				}
				return
			}
		}
		FileAppend,
			(
/* If you add this file to Winscript using the 'add' shortcut when the shortcut
 * is selected the program will first try to instanciate a class with the same 
 * name, then try and run a function with the same name and finally jump to 
 * a label with the same name. 
 *
 */
;uncomment this if you want to create a class
/*
class %shortcutName%
{	__new(controller)
	{	controller.showMessage("created the class")
		return this
	}
}
*/
;uncomment this if you want to use a function
/*
%shortcutName%(controller)
{	controller.showMessage("Called the function")
	return
}
*/
;uncomment this if you want to use a label
/*
%shortcutName%:
{	globalController.showMessage("Called the label")
	return
}
*/
/* When the shortcut is launched the global controllers 'context' is set to the
 * name of the shortcut. This allows you to activate hotkeys only when your script
 * has been launched
 */
;place the hotkeys you wish to be active while running this script here
#if GlobalController.getContext() == "%shortcutName%"
;by default the escape key will cancel your shortcut
esc::
{	globalController.clearDisplay()
	globalController.setContext("")
	return
}
;place any hotkeys you want to be active all the time here
#if
			)
			, addons\%scriptName%
		controller.edit("addons\" scriptName)
		controller.showMessage("The file " scriptName " has been created in the Addons folder. When you have finished creating the script use the 'Add' shortcut to include it into the main script")
		return this
	}
}
;JPGIncWinscriptFlag End new
;JPGIncWinscriptFlag Start display
/* A class that is able to display text to and get input from the user
 * 
 * The display has two modes (which can be switched between using capslock+v
 * whenever the display is active) high visibility and normal. High visibility
 * uses 5 gui text elements to make the text displayed appear to have a border
 * and makes it readable on any background color (where as black text is difficult
 * to read on a black background)
 *
 * The alternate display modes were introduced because the display flickers when 
 * rendering all 5 text elements in high visibility mode.
 */
class OnScreen
{	;the number of gui elements before the first 'selection' gui elements
	selectionOffput := 5
	;the number of gui elements before the 'choice' gui elements
	choiceOffput := 10
	
	;The color of the display text
	fillColor := "Black"
	;the default color of normal visibility display
	regularFillColor := "Black"
	;the fill color of the high visiblity display
	highVisFillColor := "green"
	;the outline color for high visibility display
	strokeColor := "Yellow"
	fontSize := 25
	;This value is changed whenever input is requested. Checking if this value has changed
	;will indicate if input was interrupted
	threadNumber := 1
	
	;whether to clear the display on a click
	ignoreMouseClick := false
	;whether to clear the display on the escape key
	ignoreEsc := false
	
	;an instance of the Controller class
	controller := ""
	
	;whether the gui is currently visible or not
	guiVisible := false
	;whether we are waiting for user input
	waitingForInput := false
	
	;the numer of gui elements to render. 1 for normal display 5 for high vis
	visiblitySetting := 1
	
	/* initialises the class
	 * @param controller
	 * 		an instance of the Controller class
	 */
	__New(controller)
	{	this.initialiseGui()
		this.controller := controller
		return this
	}
	
	/*	Creates the display. There are three sections:
	 * 		message at the top, centered
	 *		input just below message, centered
	 *		choices below input left aligned
	 *	@param message
	 *		an optional string to display in the message section 
	 *	@param selection
	 *		optional string to display in the selection section
	 *	@param input
	 *		optional string to display in the input section
	 * 	@param doShow
	 *		optional boolean which indicates if the window should be shown immediately
	 */
	initialiseGui(message := "", selection := "", Input := "", doShow := false)
	{	if(this.visiblitySetting != 1)
		{	messageOutline := message
			inputOutline := Input
			selectionOutline := selection
		} else
		{	messageOutline := ""
			inputOutline := ""
			selectionOutline := ""
		}
		Gui splash: destroy
		Gui splash: new
		Gui splash: Color, White
		height := A_Screenheight - 150
		width := A_ScreenWidth - 200
		Gui splash: font, % "s" this.fontSize "bold c" this.strokeColor, TimesNewRoman 
		;for the message
		Gui splash: add, text, x1 y2 Center BackgroundTrans h%height% w%width%, % messageOutline
		Gui splash: add, text, x2 y1 Center BackgroundTrans h%height% w%width%, % messageOutline
		Gui splash: add, text, x3 y2 Center BackgroundTrans h%height% w%width%, % messageOutline
		Gui splash: add, text, x2 y3 Center BackgroundTrans h%height% w%width%, % messageOutline
		Gui splash: add, text, % "x2 y2 Center BackgroundTrans c" this.fillColor " h" height " w" width, % message
		;for input
		Gui splash: add, text, x1 yp+52 Center BackgroundTrans h%height% w%width%, % inputOutline
		Gui splash: add, text, x2 yp-1 Center BackgroundTrans h%height% w%width%, % inputOutline
		Gui splash: add, text, x3 yp+1 Center BackgroundTrans h%height% w%width%, % inputOutline
		Gui splash: add, text, x2 yp+1 Center BackgroundTrans h%height% w%width%, % inputOutline
		Gui splash: add, text, % "x2 yp-1 Center BackgroundTrans c" this.fillColor " h" height " w" width, % input
		;for the selections
		Gui splash: add, text, x49 yp+52 BackgroundTrans h%height% w%width%, % selectionOutline
		Gui splash: add, text, x50 yp-1 BackgroundTrans h%height% w%width%, % selectionOutline
		Gui splash: add, text, x51 yp+1 BackgroundTrans h%height% w%width%, % selectionOutline
		Gui splash: add, text, x50 yp+1 BackgroundTrans h%height% w%width%, % selectionOutline
		Gui splash: add, text, % "x50 yp-1 BackgroundTrans c"  this.fillColor " h" height " w" width, % selection
		
		Gui, add, Edit, r2 h0 w0 WantTab WantReturn
		if(doShow)
		{	Gui splash: +lastfound -Caption +AlwaysOnTop -SysMenu +Owner
			WinSet, TransColor, white
			Gui splash: show, y120, WinscriptSplash
			this.guiVisible := true
		} else
		{	this.guiVisible := false
		}
		return
	}
	
	/*	If ignoreMouseClicks is set to true then this function does nothing
	 *	otherwise it clears the screen and cancels input
	 */
	mouseClick()
	{	if(this.ignoreMouseClick)
		{	return
		}
		return this.hide()
	}
	
	/*	If ignoreEsc is set to true then this function does nothing
	 *	otherwise it clears the screen and cancels input
	 */
	esc()
	{	if(this.ignoreEsc)
		{	return
		}
		return this.hide()
	}
	
	/* Sets the text to appear on the screen. 
	 * Sets the guiVisible variable to true
	 * @param message
	 *		A string for the message section
	 * @param choices
	 *		A string for the choices section
	 * @param selection
	 *		A string for the selection section
	 */
	display(message, choices, selection)
	{	Loop, % this.visiblitySetting
		{	GuiControl, splash:text, % "static" 6 - A_index, % message
			GuiControl, splash:text, % "static" 6 - A_index + this.selectionOffput, % selection
			GuiControl, splash:text, % "static" 6 - A_index + this.choiceOffput, % choices
		}
		Gui splash: +lastfound -Caption +AlwaysOnTop -SysMenu +Owner
		WinSet, TransColor, white
		Gui splash: show, y120, WinscriptSplash
		this.guiVisible := true
		return
	}
	
	/*	If we are waiting for input then the input is canceled. The gui isn't hidden
	 * 	in this case because in the cancelation process the gui will be hidden anyway.
	 *	
	 *	If we aren't waiting for the input then the gui is simply hidden and guiVisible is set to false
	 *	
	 *	If neither is true then nothing happens
	 */
	hide()
	{	if(this.waitingForInput == "oneChar")
		{	;cause the other input to cancel
			input, notNeeded, T0.1
			return
		} else if(this.waitingForInput == "alternate")
		{	this.updateEdit("cancelled")
			return
		}
		if(this.guiVisible)
		{	this.display("","","")
			Gui splash: hide
			this.guiVisible := false
		}
		return
	}
	
	/*
	 * Sets whether or not a click/escape key will clear the screen or not
	 * @param keys 
	 * 		keys[1] true indicates ignoring mouse clicks
	 * 		keys[2] true indicates ignoring the escape key
	 */
	setClearKeys(keys)
	{	this.ignoreMouseClick := keys.maxIndex() > 0 ? keys[1] : false
		this.ignoreEsc := keys.maxIndex() > 1 ? keys[2] : false
		return
	}
	
	/*
	 * Displays the given message. By default mouseclicks and the escape button 
	 * clear the message from the screen. Pass the optional arguments to override this behaviour.
	 * If you wish to clear the display yourself use the hide() function
	 * @param message
	 *		the string to display
	 *	@param cancelSettings
	 * 		cancelSettings[1] true indicates ignoring mouse clicks
	 * 		cancelSettings[2] true indicates ignoring the escape key
	 */
	showMessage(message, cancelSettings := "")
	{	this.setClearKeys(cancelSettings)
		this.display(message, "", "")
		return
	}
	/*
	 * Displays the given array of choices on the screen and gets input until the user selects
	 * one of the choices. By default mouseclicks clear the message from the screen. Pass the 
	 * optional arguments to override this behaviour. If you wish to clear the display yourself 
	 * use the hide() function
	 *
	 * Please note that you cannot ignore the escape key when getting input from the user because
	 * the input function captures the escape key as an 'end input' flag
	 *
	 * @param origionalChoices
	 *		An array of choices to display to the user. 
	 * @param message
	 *		A string to display in the message section
	 * @param cancelSettings
	 * 		cancelSettings[1] true indicates ignoring mouse clicks
	 *
	 * @return value
	 *		One of the items of origionalChoices
	 */
	getChoice(origionalChoices, message := "", cancelSettings := "")
	{	this.setClearKeys(cancelSettings)
		this.threadNumber++
		selection := ""
		oneChar := ""
		filteredChoices := origionalChoices
		this.updateEdit("")
		;get the input
		while true
		{	
			;~ this.display(message, this.arrayToString(filteredChoices), selection)
			;~ oneChar := this.getNextChar(this.threadNumber)
			;~ if(oneChar == "cancelled")
			;~ {	this.hide()
				;~ return "cancelled"
			;~ } else if(oneChar == "end")
			;~ {	break
			;~ } else if(oneChar == "backspace")
			;~ {	StringTrimRight, selection, selection, 1
				;~ filteredChoices := this.filterChoices(origionalChoices, selection)
			;~ } else if(oneChar == "`t")
			;~ {	;a tab rotates the list of choices
				;~ this.firstIsLast(filteredChoices, GetKeyState("shift", "P"))
			;~ } else
			;~ {	selection .= oneChar
				;~ ;order the list of choices depending on the input from the user
				;~ filteredChoices := this.filterChoices(origionalChoices, selection)
			;~ }
			
			this.display(message, this.arrayToString(filteredChoices), selection)
			selection := this.alternateInput(this.threadNumber)
			if(selection == "cancelled")
			{	this.hide()
				return selection
			} else if(instr(selection, "`n"))
			{	break
			} else if(instr(selection, "`t"))
			{	this.firstIsLast(filteredChoices, GetKeyState("shift", "P"))
				this.updateEdit(selection := RegExReplace(selection, "`t"))
				continue
			}
			filteredChoices := this.filterChoices(origionalChoices, selection)
		}
		this.hide()
		;return the top element that is being displayed to the user
		return filteredChoices[filteredChoices.minIndex()]
	}
	
	updateEdit(newValue)
	{	GuiControl, splash:, Edit1, % newValue
		return
	}
	/*
	 * Gets input from the user.
	 * @param message
	 * 		A string to display to the user
	 * @param cancelSettings
	 * 		cancelSettings[1] true indicates ignoring mouse clicks
	 * 		cancelSettings[2] true indicates ignoring the escape key
	 *
	 * @return value
	 *		The input
	 */
	getInput(message, cancelSettings := "")
	{	this.setClearKeys(cancelSettings)
		this.threadNumber++
		;required for the display method
		choices := ""
		;the input variable
		input := ""
		
		;get the input
		while true
		{	this.display(message, choices, input)
			oneChar := this.getNextChar(this.threadNumber)
			if(oneChar == "cancelled")
			{	input := "cancelled"
				break
			} else if(oneChar == "end")
			{	break
			} else if(oneChar == "backspace")
			{	StringTrimRight, input, input, 1
			} else
			{	input .= oneChar
			}
		}
		this.hide()
		return input
	}
	
	/*	Sorts an array of strings based on their similarity to a given string. 
	 *	the origional array is not modified
	 *	@param choices
	 *		An array of strings
	 * 	@param filter
	 *		A string
	 *
	 *	@return value
	 *		An array containing all the elements of choices but ordered by similarity to filter
	 */
	filterChoices(choices, filter)
	{	;If there is no filter then return choices unchanged
		if(filter == "")
		{	return choices
		}
		;an array to insert the strings into. A lower index indicates a closer relation to filter
		returnArray := object()
		
		for key, choice in choices
		{	;how similar the string is to filter
			score := 0
			compareString := filter
			
			;the filter is trimmed from the left a character at a time. If the remaining 
			;filter matches some part of the choice string then the choices score is increased
			while(compareString)
			{	;Bigger string matches are worth more
				bonus := StrLen(compareString) * 2
				
				;Does the remaining filter exist within the choice string (case sensitive)
				if(pos := RegExMatch(choice, escapeRegex(compareString)))
				{	score += bonus
					;if it is at the start then double the score
					if(pos == 1)
					{	score += bonus
					}
				}
				
				;if it is not the same case?
				if(pos := RegExMatch(choice, "i)" escapeRegex(compareString)))
				{	score += bonus
					if(pos == 1)
					{	score += bonus
					}
				}
				
				;does it exist not at the start but as word within the choice?
				if(RegExMatch(choices, "\W" escapeRegex(compareString)))
				{	score += bonus
				}
				
				;if the string matches exactly then its score is bumped up 
				if(RegExMatch(choice, "i)^" escapeRegex(compareString) "$"))
				{	score *= 100
				}
				StringTrimLeft, compareString, compareString, 1
			}
			
			;items with the same score are moved the the next lowest free index.
			;If the scores are too close together then the ordering is lost
			score *= -1000
			while(returnArray.hasKey(score))
			{ ;increment score until there is a free spot
				score++
			}
			returnArray.Insert(score, choice)
		}
		return returnArray
	}
	
	/* Gets one character from the keyboard. In order to not block alt-tab type
	 * combinations gathering input is suspended when alt, ctrl or win keys are pressed
	 * and resumed when the key is released.
	 *
	 * @return value
	 *		a single character 
	 *		or 'backspace' if backspace was pressed 
	 *		or 'end' if enter was pressed
	 *		or 'cancelled' if escape was pressed
	 */
	getNextChar(interrupted)
	{	if(interrupted != this.threadNumber)
		{	return "cancelled"
		}
		this.waitingForInput := "oneChar"
		input, oneChar, L1,{Esc}{BackSpace}{enter}{Lalt}{RAlt}{Lctrl}{RCtrl}{LWin}{RWin}
		if(interrupted != this.threadNumber)
		{	return "cancelled"
		}
		this.waitingForInput := false
		if(ErrorLevel == "EndKey:Backspace")
		{ 	return "backspace"
		} else if(ErrorLevel == "EndKey:Escape" || ErrorLevel == "NewInput")
		{	return "cancelled"
		}else if(ErrorLevel == "EndKey:Enter")
		{	return "end"
		} else if(InStr(errorLevel, "EndKey:"))
		{	StringReplace, keyName, ErrorLevel, EndKey:
			send {%keyName% down}
			KeyWait, % keyName
			return this.getNextChar(interrupted)
		}
		return oneChar
	} 
	 
	alternateInput(interrupted)
	{	this.waitingForInput := "alternate"
		GuiControlGet, currentInput, splash:, % "static" this.choiceOffput
		guicontrol, focus, splash: Edit1
		while(true)
		{	if(interrupted != this.threadNumber)
			{	currentInput := "cancelled"
				break
			}
			GuiControlGet, newInput, splash:, Edit1
			if(newInput != currentInput)
			{	currentinput := newInput
				break
			}
		
			gui splash:+LastFound
			IfWinNotActive
			{	this.waitModifierKeys()
				gui splash:+LastFound
				WinActivate
				guicontrol, focus, splash: Edit1
			}
			sleep, 50
		}
		this.waitingForInput := false
		return currentInput
	}
	
	waitModifierKeys()
	{	KeyWait, Control
		KeyWait, Alt
		KeyWait, LWin
		KeyWait, rWin
		return
	}
	
	/*	Takes an array and either makes the first element the last or the opposite
	 *	this function changes the origional array
	 *	@param theArray
	 *		an array containing any type of element
	 *	@param reverse
	 *		A boolean. if true the last element is made the first
	 */
	firstIsLast(ByRef theArray, reverse)
	{	if(reverse)
		{	removed := theArray.remove(theArray.maxIndex())
			theArray.insert(theArray.minIndex() - 1, removed)
		} else
		{	removed := theArray.remove(theArray.minIndex())
			theArray.insert(theArray.maxIndex() + 1, removed)
		}
		return
	}
	
	/*	Converts an array to a string
	 */
	arrayToString(theArray)
	{	theString := ""
		for key, aString in theArray
		{	if(trim(aString) == "")
			{	continue
			}
			theString .= aString "`n"
		}
		return theString
	}	
	
	/*	swaps between high vis and normal display modes
	 */
	toggleVisiblitySettings()
	{	SetTimer, RemoveToolTip, Off
		SetTimer, removeTooltip, 2000
		GuiControlGet, message, splash:, static5
		GuiControlGet, input, splash:, % "static" this.choiceOffput + 5
		GuiControlGet, selection, splash:, % "static" this.selectionOffput + 5
		if(this.visiblitySetting == 1)
		{	this.visiblitySetting := 5
			this.fillColor := this.highVisFillColor
			ToolTip, High visiblity menu turned ON
		} else
		{	this.visiblitySetting := 1
			this.fillColor := this.regularFillColor
			ToolTip, High visiblity menu turned OFF
		}
		this.initialiseGui(message, input, selection, true)
		return	
	}
}
splashguiclose:
{	globalController.clearDisplay()
	return
}
removeTooltip:
{	SetTimer, RemoveToolTip, Off
	ToolTip
	return
}
;JPGIncWinscriptFlag End display
;JPGIncWinscriptFlag Start unpack
unpack()
{	SetWorkingDir, % A_ScriptDir
	IfNotExist, Addons
	{	FileCreateDir, Addons
	}
	recompiler := new recompiler()
	beforeFlag := recompiler.getBeforeFlag()
	afterFlag := recompiler.getAfterFlag()
	source := recompiler.getRunningCode()
	fileName := ""
	warnings := ""
	
	Loop, parse, source, `n, `r
	{	if(RegExMatch(A_loopfield, "m)^" beforeFlag))
		{	filename := RegExReplace(A_loopfield, "m)^" beforeFlag "(.*)", "$1")
			IfNotInString, fileName, .
			{	filename .= ".ahk"
			}
			IfExist, Addons\%fileName%
			{	warnings .= fileName "`n"
				filename := "" ;dont append to an already existing file
			}
			continue
		}
		if(RegExMatch(A_loopfield, "m)^" afterFlag))
		{	filename := ""
		}
		if(filename != "")
		{	FileAppend, % A_loopfield, Addons\%filename%
		}
	}
	if(warnings)
	{	MsgBox, , JPGInc Warning, Warning the following files already existed and were not unpacked`n%warnings%
	} else
	{	MsgBox, , JPGInc Success, Files unpacked successfully
	}
	return
}
;JPGIncWinscriptFlag End unpack

;JPGIncWinscriptFlag Start add
/* This function merges a new code segment into the running code.
 * The user is prompted for a shortcut name which must not be
 * the same as an already merged code segment. 
 * 
 * The code segment may be added as a new 'shortcut' in which case
 * a shortcut is added to the default shortcut list. If a file exists
 * in the Addons folder with the same name as the shortcut then it is
 * used otherwise the user is prompted to select a file. 
 * 
 * After the code segment is added the script is reloaded
 * @param controller
 *		An instance of the Controller class
 */
add(controller)
{	while(true)
	{	;get the name of the new code segment
		newShortcut := controller.getInput("Type a shortcut name.")
		if(newShortcut == "cancelled")
		{	return
		}
		;make sure the name is valid
		if(! controller.isValidShortcut(newShortcut))
		{	MsgBox, , JPGInc ERROR, Error that shortcut is invalid or already in use
		} else
		{	;load the code
			IfExist, % A_scriptdir "\Addons\" newShortcut ".ahk"
			{	FileRead, newCode, % A_ScriptDir "\Addons\" newShortcut ".ahk"
			} else
			{	controller.showMessage("Select the file to load", ignoreMouseClicks := true)
				FileSelectFile, dir, 3 ,% A_ScriptDir "\Addons"
				if(errorlevel)
				{	controller.clearDisplay()
					return ;the user cancelled
				}
				dir := RegExReplace(dir, "\R")
				controller.clearDisplay()
				FileRead, newCode, % dir
			}
			if(! newCode)
			{	MsgBox, , JPGInc ERROR, Error file could not be read or was empty
				return
			}
			recomp := new recompiler(controller)
			MsgBox, 4, JPGInc, Would you like to add this shortcut to the default shortcut list?
			IfMsgBox Yes
			{	recomp.addShortcut(newShortcut, newCode)
			} else 
			{	recomp.add(newShortcut, newCode)
			}	
			return
		}
	}
}
;JPGIncWinscriptFlag End add
