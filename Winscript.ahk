;JPGIncWinscriptFlag Start shortcutNames
/* This program was written by Joshua Graham joshua.graham@jpgautomation.com
 * www.jpgautomation.com
 * Anyone may use any part of this code for any non-malicious purpose
 * with or without referencing me. There is No Warranty 
 */
;Do not edit this file.
JPGIncShortcuts := "remove,edit,add,update,new,unpack,"
JPGIncCodeSegments := "autoExecute,defaultHotkeys,display,controller,shortcutLauncher,recompiler,"
;JPGIncWinscriptFlag End shortcutNames
;JPGIncWinscriptFlag Start autoExecute
/*
 * This file is always included first in the compilation process and is the auto execute secion
 * of the script
 */
#NoEnv  ; Recommended for performance and compatibility with future AutoHotkey releases.
; #Warn  ; Enable warnings to assist with detecting common errors.
SendMode Input  ; Recommended for new scripts due to its superior speed and reliability.
SetWorkingDir %A_ScriptDir%  ; Ensures a consistent starting directory.
#SingleInstance force
if not A_IsAdmin
{	Run *RunAs "%A_ScriptFullPath%" 
	ExitApp
}
IfNotExist, Addons
{   MsgBox, 4, JPGInc ERROR, ERROR the Addons folder does not exist. Would you like to create and populate the folder now?
    IfMsgBox, Yes
    {   unpack()
    }
}
GlobalController := new Controller(JPGIncShortcuts, JPGIncCodeSegments)
return
;JPGIncWinscriptFlag End autoExecute
;JPGIncWinscriptFlag Start defaultHotkeys
#If
;Capslock + Esc exits the program
~CapsLock & Esc::
~Esc & CapsLock::
{	KeyWait capslock
	KeyWait esc
	SetCapsLockState, off
	ExitApp
}
;the default keys to enter 'script' mode are shift and capslock together
~shift & CapsLock::
~CapsLock & Shift::
{	KeyWait shift
	KeyWait capslock
	SetCapsLockState, off
	GlobalController.enterScriptMode()
	return
}
;clicking a mouse button by default will leave script mode
~LButton::
~RButton::
~MButton::
{	GlobalController.mouseClick()
	return
}
;
~Esc::
{	GlobalController.esc()
	return
}
;JPGIncWinscriptFlag End defaultHotkeys
;JPGIncWinscriptFlag Start edit
class edit
{	__new(controller)
	{	while(true)
		{	toEdit := controller.getChoice(controller.getAllShortcuts(), "Select a code segment/shortcut to edit")
			if(toEdit == "cancelled")
			{	return
			}
			if(controller.codeOrShortcutExists(toEdit))
			{	IfNotExist, % A_ScriptDir "\Addons\" toEdit ".ahk"
				{	MsgBox, , JPGInc ERROR, ERROR file does not exists in the Addons folder.
					return
				}
				run, edit "%A_ScriptDir%\Addons\%toEdit%.ahk", , UseErrorLevel
				if(errorLevel)
				{	run, % "notepad """ A_ScriptDir "\Addons\" toEdit ".ahk"""
				}
				return
			} else
			{	MsgBox, , JPGInc ERROR, ERROR that shortcut does not exist!
			}
		}
	}
}
;JPGIncWinscriptFlag End edit
;JPGIncWinscriptFlag Start add
class add
{	__new(controller)
	{	while(true)
		{	newShortcut := controller.getInput("Type a shortcut name.")
			if(newShortcut == "cancelled")
			{	return
			}
			if(! controller.isValidShortcut(newShortcut))
			{	MsgBox, , Error, Error that shortcut is invalid or already in use
			} else
			{	IfExist, % A_scriptdir "\Addons\" newShortcut ".ahk"
				{	FileRead, newCode, % A_ScriptDir "\Addons\" newShortcut ".ahk"
				} else
				{	controller.showMessage("Select the file to load", ignoreMouseClicks := true)
					FileSelectFile, dir, 12 ,% A_ScriptDir "\Addons"
					if(errorlevel)
					{	controller.clearDisplay()
						return ;the user cancelled
					}
					controller.clearDisplay()
					FileRead, newCode, % dir
				}
				if(! newCode)
				{	MsgBox, , Error, Error file could not be read or was empty
					return
				}
				recomp := new recompiler(controller)
				MsgBox, 4, JPGInc, Would you like to add this shortcut to the default shortcut list?
				IfMsgBox Yes
				{	recomp.addShortcut(newShortcut, newCode)
				} else 
				{	recomp.add(newShortcut, newCode)
				}	
				return
			}
		}
			
	}
}
;JPGIncWinscriptFlag End add
;JPGIncWinscriptFlag Start update
class update
{	__new(controller)
	{	while(true)
		{	toUpdate := controller.getChoice(controller.getAllShortcuts(), "Select a code segment to update")
			if(toUpdate == "cancelled")
			{	return
			}
			if(! controller.validShortcut(newShortcut))
			{	IfExist, % A_scriptdir "\Addons\" toUpdate ".ahk"
				{	FileRead, newCode, % A_ScriptDir "\Addons\" toUpdate ".ahk"
				} else
				{	controller.showMessage("Select the file to load", ignoreMouseClicks := true)
					FileSelectFile, dir, 12 ,% A_ScriptDir "\Addons"
					if(errorlevel)
					{	controller.clearDisplay()
						return ;the user cancelled
					}
					controller.clearDisplay()
					FileRead, newCode, % dir
				}
				if(! newCode)
				{	MsgBox, , Error, Error file could not be read or was empty
					return
				}
				MsgBox, 4, Warning, Are you sure you wish to update the shortcut %toUpdate%?
				IfMsgBox, No
				{	return
				}
				r := new recompiler()
				r.update(toUpdate, newCode)
			} else
			{	MsgBox, , Error, Error that shortcut does not exist
			}
		}
		return this
	}
}
;JPGIncWinscriptFlag End update
;JPGIncWinscriptFlag Start remove
class remove
{	__new(controller)
	{	while(true)
		{	toRemove := controller.getChoice(controller.getAllShortcuts(), "Select a code segment/shortcut to remove")
			if(toRemove == "cancelled")
			{	return
			}
			if(toRemove == "autoExecute")
			{	MsgBox, , ERROR, Error you cannot remove the autoExecute section. Use edit/update instead
				return
			}
			if(controller.codeOrShortcutExists(toRemove))
			{	MsgBox, 4, Warning, Are you sure you wish to remove the code segment %toRemove%?
				IfMsgBox, No
				{	return
				}
				r := new recompiler()
				r.remove(toRemove)
			} else
			{	MsgBox, , Error, Error that shortcut does not exist
			}
		}
		return this
	}
}
;JPGIncWinscriptFlag End remove
;JPGIncWinscriptFlag Start controller
class Controller
{	display := new OnScreen(this)
	context := ""
	shortcuts := ""
	codeSegments := ""
	allShortcuts := ""
	
	__new(shortcuts, codeSegments)
	{	this.shortcuts := StrSplit(shortcuts, ",")
		this.codeSegments := StrSplit(codeSegments, ",")
		this.allShortcuts := StrSplit(shortcuts "," codeSegments, ",")
		return this
	}
	
	enterScriptMode()
	{	this.context := "shortcutLauncher"
		shortcutLauncher(this)
		return
	}
	mouseClick()
	{	this.display.mouseClick()
		return
	}
	esc()
	{	this.display.esc()
		return
	}
	showMessage(message, params*)
	{	return this.display.showMessage(message, params)
	}
	clearDisplay()
	{	return this.display.hide()
	}
	getChoice(choices, message := "", params*)
	{	return this.display.getChoice(choices, message, params)
	}
	getInput(message, params*)
	{	return this.display.getInput(message, params)
	}
	setContext(newContext)
	{	this.context := newContext
		return
	}
	getContext()
	{	return this.context
	}
	getShortcuts()
	{	return this.shortcuts
	}
	getCodeSegments()
	{	return this.codeSegments
	}
	getAllShortcuts()
	{	return this.allShortcuts
	}
	isValidShortcut(newShortcut)
	{	if(newShortcut == "")
		{	return false
		}
		IfInString, newShortcut, `,
		{	return false
		}
		return ! (this.shortcutExists(newShortcut) || this.codeSegmentExists(newShortcut))
	}
	shortcutExists(newShortcut)
	{	newShortcut := trim(newShortcut)
		if(newShortcut == "")
		{	return false
		}
		IfInString, newShortcut, `,
		{	return false
		}
		return this.inArray(this.shortcuts, newShortcut)
	}
	codeSegmentExists(newShortcut)
	{	newShortcut := trim(newShortcut)
		if(newShortcut == "")
		{	return false
		}
		IfInString, newShortcut, `,
		{	return false
		}
		return this.inArray(this.codeSegments, newShortcut)
	}
	codeOrShortcutExists(shortcut)
	{	return this.inArray(this.shortcuts, shortcut) || this.inArray(this.codeSegments, shortcut)
	}
	inArray(array, item)
	{	for key, val in array
		{	if(val == item)
			{	return true
			}
		}
		return false
	}
	edit(filename)
	{	Run, edit "%filename%", , UseErrorLevel
		if(errorlevel)
		{	run, notepad "%filename%"
		}
		return
	}
}
;JPGIncWinscriptFlag End controller
;JPGIncWinscriptFlag Start recompiler
class recompiler
{
    beforeFlag := ";JPGIncWinscriptFlag Start "
    afterFlag := ";JPGIncWinscriptFlag End "
    
    __New(args*)
    {   return this
    }
    
    getBeforeFlag()
    {   return this.beforeFlag
    }   
    getAfterFlag()
    {   return this.afterFlag
    }
    
    getRunningCode() 
    {   if(A_IsCompiled) 
        {   MsgBox, , ERROR, ERROR Cannot edit this script because it is already compiled!
            return ""
        ;not yet implemented
        } else 
        {   FileRead, fullScript, % A_ScriptFullPath
        }
        return fullScript
    }
    
    /*
     * Simply appends the given file to the main script without adding a sortcut
     * @param filename
     *  the full path of the file to include OR the name of the file in the %A_scriptdir%\Addons folder
     * @param shortcutName
     *  the name of the shortcut. If blank a shortcut is not added and the file is simply appended to the running code
     */
    doAdd(name, newCode, addShortcut) 
    {   runningCode := this.getSource()
        if(this.joinCode(name, newCode, runningCode, addShortcut)) 
        {   MsgBox, 4, JPGInc Warning, Warning adding this file will overwite existing code`nDo you want to continue?
            IfMsgBox, no 
            {   return
            }
        }
		return this.recompile(runningCode)
    }
    
    /*
     * Edit's existingCode to include newCode in between beforeflag and afterflag optionally updating the defaultShortcutList := "..." to include name ","
     * returns false if the code was added without removing existing code
     * returns true existing code was updated
     */
    joinCode(name, newCode, ByRef existingCode, addShortcut, isUpdate := false) 
    {	if(theStart := RegExMatch(existingCode, "`am)^" this.escapeRegex(this.beforeFlag name) "$")) 
        {   ;we need to replace the existing code
            MsgBox % "here " theStart
            theEnd := RegExMatch(existingCode, "P`am)^" this.escapeRegex(this.afterFlag name) "$", length)
            existingCode := SubStr(existingCode, 1, theStart - 1) SubStr(existingCode, theEnd + length)
        }
        if(! isUpdate)
        {   if(addShortcut && ! theStart) 
            {   ;need to add the shortcut
                existingCode := RegExReplace(existingCode, "`am)^JPGIncShortcuts := ""(.*)""", "JPGIncShortcuts := ""$1" this.escapeDollars(name) ",""", notNeeded, 1)
            } else if (! theStart)
            {   existingCode := RegExReplace(existingCode, "`am)^JPGIncCodeSegments := ""(.*)""", "JPGIncCodeSegments := ""$1" this.escapeDollars(name) ",""", notNeeded, 1)
            }
        }
        if(name == "autoExecute")
        {   theEnd := RegExMatch(existingCode, "P`am)^" this.escapeRegex(this.afterFlag "shortcutNames") "$", length)
            shortcutNames := SubStr(existingCode, 1, theEnd + length)
            otherCode := SubStr(existingCode, theEnd + length)
            ;special case where the code has to be added to the start of the script but after the shortcutNames section
            existingCode := shortcutNames "`n" this.beforeFlag name "`n" newCode "`n" this.afterFlag name "`n" otherCode
        } else
        {   ;append the new code with flags
            existingCode .= "`n" this.beforeFlag name "`n" newCode "`n" this.afterFlag name "`n"
        }
        return theStart != 0
    }
    
    /*
     * removes from the start flag of 'name' to the endflag (inclusive) from 'existingCode'
     * returns 0 if successful
     * returns 1 if unsuccessful
     */
    splitCode(name, ByRef existingCode, deleteShortcut := false)
    {   if(theStart := RegExMatch(existingCode, "`am)^" this.escapeRegex(this.beforeFlag name) "$")) 
        {	theEnd := RegExMatch(existingCode, "P`am)^" this.escapeRegex(this.afterFlag name) "$", length)
            existingCode := SubStr(existingCode, 1, theStart - 1) SubStr(existingCode, theEnd + length)
            existingCode := RegExReplace(existingCode, "\R\R", "`r`n")
            if(deleteShortcut)
            {   existingCode := RegExReplace(existingCode, "m)""(.*)" this.escapeRegex(name) ",", """$1", notNeeded, 1)
            }
            return 0
        }
        return 1
    }
    /*
     * Appends the given file to the main script also adding it to the shortcut list
     */
    addShortcut(name, newCode) 
    {   return this.doAdd(name, newCode, true)
    }
    
    add(name, newCode) 
    {   return this.doAdd(name, newCode, false)
    }
    
    /*
     * Removes the code snipit from the main file
     */
    remove(name, update := false) 
    {   existingCode := this.getSource()
        if(this.splitCode(name, existingCode, deleteShortcut := true))
        {   MsgBox, , JPGInc Error, Error code segment not found in the currently running code!
            return 
        }
        return this.recompile(existingCode)
    }
    
    /* 
     * Updates an existing code snipit within the file
	 * Not yet implemented
     */
    update(name, newCode) 
    {	existingCode := this.getSource()
        if(this.splitCode(name, existingCode))
        {   MsgBox, 4, JPGInc Warning, Warning existing code was not found (or removed) do you wish to continue?
			IfMsgBox No
			{	return
			}
		}
		this.joinCode(name, newCode, existingCode, addShortcut := false, isUpdate := true)
		return this.recompile(existingCode)
    }
    
    /*
     * Checks if the given code will compile
     * returns 0 if the code compiles without any problems
     * returns the compilation errors otherwise
     */
    checkCodeSyntax(code) 
    {
        FileDelete, JPGIncTempFile.ahk
        FileDelete, errorlog.txt
        FileAppend, % "exitapp`n" code, JPGIncTempFile.ahk
        RunWait, %A_AhkPath% /ErrorStdOut JPGIncTempFile.ahk > errorlog.txt
        FileDelete, JPGIncTempFile.ahk
        FileRead, errorlog, errorlog.txt
        if(errorlog)
        {   return errorlog
        }
        return false
    }
    
    /*
     * returns the code of the currently running script
     */
    getSource() 
    {
        if(A_IsCompiled) 
        {
            ;not yet implemented
        } else 
        {
            FileRead, fullScript, % A_ScriptFullPath
        }
        return fullScript
    }
    
    recompile(newCode) 
    {	if(A_IsCompiled) 
        {	return
            ;not implemented
        } else 
        {	FileMove, % A_scriptfullpath, % a_scriptfullpath ".backup", 1
            FileAppend, % newCode, % A_scriptfullpath
            Reload
            Sleep 1000 ; If successful, the reload will close this instance during the Sleep, so the line below will never be reached.
			WinClose, ahk_class #32770
			FileMove, % A_ScriptFullPath, % A_ScriptFullPath ".failed", 1
			FileMove, % A_scriptfullpath ".backup", % a_scriptfullpath, 1
            MsgBox, 4, JPGInc ERROR, ERROR The script could not be reloaded. Would you like to open it for editing?
            IfMsgBox, Yes 
            {   Run, edit "%A_scriptfullpath%.failed", , UseErrorLevel
				if(errorlevel)
				{	run, % "notepad """ A_scriptfullpath ".failed"""
				}
            }
            return
        }
    }
	
	doMatch(haystack, needle)
	{	return RegExMatch(haystack, "`am)^" needle "$")
	}
	
	escapeRegex(theString) 
	{	return "\Q" RegExReplace(theString, "(\Q|\E)", "\$1") "\E"
	}
	
	escapeDollars(theString)
	{	StringReplace, theString, theString, $, $$, all
		return theString
	}
}
;JPGIncWinscriptFlag End recompiler
;JPGIncWinscriptFlag Start shortcutLauncher
/* This is the class that will be loaded when entering script mode 
 * Displays a list of shorcuts to choose from
 */
shortcutLauncher(controller)
{	className := controller.getChoice(controller.getShortcuts(), "Select script to run")
	if(className == "cancelled")
	{	return
	}
	StringReplace, className, className, %A_space%, _ , All
	controller.setContext(className)
	if(IsObject(%className%))
	{	new %className%(controller)
	} else if((argCount := IsFunc(className)))
	{	if(argCount == 1)
		{	%className%()
		} else
		{	%className%(controller)
		}
	} else if(IsLabel(className))
	{	gosub, %className%
	}
	return
}
;JPGIncWinscriptFlag End shortcutLauncher
;JPGIncWinscriptFlag Start new
class new
{	
	
	__new(controller)
	{	shortcutName := scriptName := controller.getInput("Enter the name of your new script. Ideally the name will be the same as the shortcut you intend to use")
		if(scriptName == "cancelled" || trim(scriptName) == "")
		{	return
		}
		StringReplace, shortcutName, shortcutName, %A_space%, _, All
		IfNotInString, scriptName, .
		{	scriptname .= ".ahk"
		}
		{	IfExist, addons\%scriptName%
			{	MsgBox, 4, JPGInc Warning, Warning, the file %scriptName% already exists in the Addons folder. Would you like to open it for editing?
				IfMsgBox, Yes
				{	controller.edit("addons\" scriptName)
				}
				return
			}
		}
		FileAppend,
			(
/* If you add this file to Winscript using the 'add' shortcut when the shortcut
 * is selected the program will first try to instanciate a class with the same 
 * name, then try and run a function with the same name and finally jump to 
 * a label with the same name. 
 *
 */
;uncomment this if you want to create a class
/*
class %shortcutName%
{	__new(controller)
	{	controller.showMessage("created the class")
		return this
	}
}
*/
;uncomment this if you want to use a function
/*
%shortcutName%(controller)
{	controller.showMessage("Called the function")
	return
}
*/
;uncomment this if you want to use a label
/*
%shortcutName%:
{	globalController.showMessage("Called the label")
	return
}
*/
/* When the shortcut is launched the global controllers 'context' is set to the
 * name of the shortcut. This allows you to activate hotkeys only when your script
 * has been launched
 */
;place the hotkeys you wish to be active while running this script here
#if GlobalController.getContext() == "%shortcutName%"
;by default the escape key will cancel your shortcut
esc::
{	globalController.clearDisplay()
	globalController.setContext("")
	return
}
;place any hotkeys you want to be active all the time here
#if
			)
			, addons\%scriptName%
		controller.edit("addons\" scriptName)
		controller.showMessage("The file " scriptName " has been created in the Addons folder. When you have finished creating the script use the 'Add' shortcut to include it into the main script")
	}
}
;JPGIncWinscriptFlag End new
;JPGIncWinscriptFlag Start unpack
unpack()
{	IfNotExist, Addons
	{	FileCreateDir, Addons
	}
	recompiler := new recompiler()
	beforeFlag := recompiler.getBeforeFlag()
	afterFlag := recompiler.getAfterFlag()
	source := recompiler.getRunningCode()
	fileName := ""
	warnings := ""
	
	Loop, parse, source, `n
	{	if(RegExMatch(A_loopfield, "m)^" beforeFlag))
		{	filename := RegExReplace(A_loopfield, "m)^" beforeFlag "(.*)\R", "$1")
			IfNotInString, fileName, .
			{	filename .= ".ahk"
			}
			IfExist, Addons\%fileName%
			{	warnings .= fileName "`n"
				filename := "" ;dont append to an already existing file
			}
			continue
		}
		if(RegExMatch(A_loopfield, "m)^" afterFlag))
		{	filename := ""
		}
		if(filename != "")
		{	FileAppend, % A_loopfield, Addons\%filename%
		}
	}
	if(warnings)
	{	MsgBox, , JPGInc Warning, Warning the following files already existed and were not unpacked`n%warnings%
	} else
	{	MsgBox, , JPGInc Success, Files unpacked successfully
	}
	return
}
;JPGIncWinscriptFlag End unpack


;JPGIncWinscriptFlag Start display
/* A class that is able to display a message and/or present a list of items 
 * for the user to select from
 */
class OnScreen
{	selectionOffput := 5
	choiceOffput := 10
	fillColor := "Green"
	strokeColor := "Yellow"
	fontSize := 25
	ignoreMouseClick := false
	ignoreEsc := false
	controller := ""
	guiVisible := false
	waitingForInput := false
	
	/* 
	 * Creates a gui 
	 */
	__New(controller)
	{	Gui splash: new
		Gui splash: Color, White
		height := A_Screenheight - 150
		width := A_ScreenWidth - 200
		Gui splash: font, % "s" this.fontSize "bold c" this.strokeColor, TimesNewRoman 
		;for the message
		Gui splash: add, text, x1 y2 Center BackgroundTrans h%height% w%width%
		Gui splash: add, text, x2 y1 Center BackgroundTrans h%height% w%width%
		Gui splash: add, text, x3 y2 Center BackgroundTrans h%height% w%width%
		Gui splash: add, text, x2 y3 Center BackgroundTrans h%height% w%width%
		Gui splash: add, text, % "x2 y2 Center BackgroundTrans c" this.fillColor " h" height " w" width
		;for input
		Gui splash: add, text, x1 yp+52 Center BackgroundTrans h%height% w%width%
		Gui splash: add, text, x2 yp-1 Center BackgroundTrans h%height% w%width%
		Gui splash: add, text, x3 yp+1 Center BackgroundTrans h%height% w%width%
		Gui splash: add, text, x2 yp+1 Center BackgroundTrans h%height% w%width%
		Gui splash: add, text, % "x2 yp-1 Center BackgroundTrans c" this.fillColor " h" height " w" width
		;for the selections
		Gui splash: add, text, x49 yp+52 BackgroundTrans h%height% w%width%
		Gui splash: add, text, x50 yp-1 BackgroundTrans h%height% w%width%
		Gui splash: add, text, x51 yp+1 BackgroundTrans h%height% w%width%
		Gui splash: add, text, x50 yp+1 BackgroundTrans h%height% w%width%
		Gui splash: add, text, % "x50 yp-1 BackgroundTrans c"  this.fillColor " h" height " w" width
		this.controller := controller
		return this
	}
	
	mouseClick()
	{	if(this.ignoreMouseClick)
		{	return
		}
		return this.hide()
	}
	
	esc()
	{	if(this.ignoreEsc)
		{	return
		}
		return this.hide()
	}
	
	display(message, choices, selection)
	{	if(params.maxIndex())
		{	this.ignoreMouseClick := params[1]
			this.ignoreEsc := params.maxIndex() > 1 ? params[2] : false
		}
		;the message
		Loop, 5
		{	GuiControl, splash:text, static%A_index%, % message
		}
		;the choices
		loop, 5
		{	GuiControl, splash:text, % "static" A_index + this.selectionOffput, % selection
			GuiControl, splash:text, % "static" A_index + this.choiceOffput, % choices
		}
		Gui splash: +lastfound +disabled -Caption +AlwaysOnTop -SysMenu +Owner
		WinSet, TransColor, white
		Gui splash: show, NoActivate y120, WinscriptSplash
		this.guiVisible := true
		return
	}
	
	/*
	 * clear the display
	 */
	hide()
	{	if(this.waitingForInput)
		{	Gui splash: +lastfound
			send {esc}
			return
		}
		if(this.guiVisible)
		{	this.display("","","")
			Gui splash: hide
			this.guiVisible := false
		}
		return
	}
	
	/*
	 * Sets whether or not a click/escape key will clear the screen or not
	 * @params[1] 
	 * 		true indicates ignoring mouse clicks
	 * @params[2]
	 *		true indicates ignoring the escape key
	 */
	setClearKeys(keys)
	{	this.ignoreMouseClick := keys.maxIndex() > 0 ? keys[1] : false
		this.ignoreEsc := keys.maxIndex() > 1 ? keys[2] : false
		return
	}
	
	/*
	 * Displays the given message. By default mouseclicks and the escape button 
	 * clear the message from the screen. Pass the optional arguments to override this behaviour.
	 * If you wish to clear the display yourself use the clear() function
	 * usage:
	 * showMessage(message to display[, array[1] = ignoreMouseClick, array[2] = ignoreEsc])
	 */
	showMessage(message, optionalArgs := "")
	{	this.setClearKeys(optionalArgs)
		this.display(message, "", "")
		return
	}
	/*
	 * Displays the given array of choices on the screen and gets input until the user selects
	 * one of the choices. By default mouseclicks clear the message from the screen. Pass the 
	 * optional arguments to override this behaviour. If you wish to clear the display yourself 
	 * use the clear() function
	 * usage:
	 * getChoices(array of Choices[, message to display = "", ignoreMouseClick = false])
	 */
	getChoice(origionalChoices, message := "", optionalArgs := "")
	{	this.setClearKeys(optionalArgs)
		;you cannot ignore the escape key when getting input
		this.ignoreEsc := false
		selection := ""
		oneChar := ""
		
		;get the input
		while true
		{	filteredChoices := this.filterChoices(origionalChoices, selection)
			this.display(message, this.arrayToString(filteredChoices), selection)
			oneChar := this.getNextChar()
			if(oneChar == "cancelled")
			{	this.hide()
				return "cancelled"
			} else if(oneChar == "end")
			{	break
			} else if(oneChar == "backspace")
			{	StringTrimRight, selection, selection, 1
			} else
			{	selection .= oneChar
			}
		}
		this.hide()
		;get the input
		return filteredChoices.maxIndex() > 0 ? filteredChoices[1] : selection
	}
	/*
	 * Gets input from the user.
	 * usage: 
	 * getInput(message to display[, ignore mouse click = false])
	 */
	getInput(message, optionalArgs := "")
	{	this.setClearKeys(optionalArgs)
		;you cannot ignore the escape key when getting input
		this.ignoreEsc := false
		choices := ""
		selection := ""
		oneChar := ""
		
		;get the input
		while true
		{	this.display(message, choices, selection)
			oneChar := this.getNextChar()
			if(oneChar == "cancelled")
			{	selection := "cancelled"
				break
			} else if(oneChar == "end")
			{	break
			} else if(oneChar == "backspace")
			{	StringTrimRight, selection, selection, 1
			} else
			{	selection .= oneChar
			}
		}
		this.hide()
		return selection
	}
	
	/* Eventually I want to make this intelligent
	 * now it sorts a given array of strings by how similar they are to the given string filter
	 */
	filterChoices(choices, filter)
	{	if(filter == "")
		{	return choices
		}
		sortedChoices := object()
		returnArray := Object()
		;~ returnString := ""
		filterChars := StrSplit(filter)
		for key, choice in choices
		{	score := 0
			consecutiveCharReward := 1
			bonus := 0
			for index, char in filterChars
			{	if((found := InStr(choice, char)))
				{	if(found == 1 && index == 1)
					{	;the first char in the filter matches the first char of the choice
						bonus := 2
					}
					if(found == index)
					{	bonus *= 2
					}
					;the more consecutive matching chars the higher the score
					consecutiveCharReward *= 2
					score += consecutiveCharReward + bonus
				} else
				{	consecutiveCharReward := 1
					bonus := 1
				}	
			}
			while(sortedChoices.hasKey(score))
			{ ;increment score until there is a free spot
				score++
			}
			sortedChoices.Insert(score, choice)
		}
		
		while((highestScore := sortedChoices.remove(sortedChoices.maxIndex())) != "")
		{	returnArray.insert(highestScore)
		}
		;~ while((temp := sortedChoices.remove(sortedChoices.maxIndex())) != "")
		;~ {	
			;~ returnString .= temp "`n"
		;~ }
		;~ return returnString
		return returnArray
	}
	
	/* Gets one character from the user 
	 * returns "cancelled" if the escape key is pressed 
	 * returns "end" if return was pressed
	 * takes a string and returns that string with the next character appeneded to it
	 */
	getNextChar()
	{	this.waitingForInput := true
		input, oneChar, L1,{Esc}{BackSpace}{enter}
		this.waitingForInput := false
		if(ErrorLevel == "EndKey:Backspace")
		{ 	return "backspace"
		} else if(ErrorLevel == "EndKey:Escape")
		{	return "cancelled"
		}
		if(InStr(errorLevel, "EndKey:"))
		{	return "end"
		}
		return oneChar
	}
	arrayToString(theArray)
	{	theString := ""
		for key, aString in theArray
		{	theString .= aString "`n"
		}
		return theString
	}	
}
;JPGIncWinscriptFlag End display
